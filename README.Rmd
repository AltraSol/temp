---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
options(tibble.print_min = 5, tibble.print_max = 5, pillar.bold = TRUE)
```

# vary <a href='https://github.com/ulchc/vary'><img src='man/figures/logo.png' align="right" height="139" /></a>
<!-- badges: start -->
[![R-CMD-check](https://github.com/ulchc/vary/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/ulchc/vary/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

## Overview
Methods to reliably structure data when the source format or load point is expected to vary over time; or when inputs lack structure completely and are not immediately compatible with typical data manipulation packages. For situations where connection points are pdfs or user-edited Excel sheets, and table dimensions and naming conventions need to be dynamically set using pattern recognition. 

## Motivation
To enhance code readability and increase the resilience of data pipelines between uncommon sources and standardized reports. In keeping with the report oriented end result, a few methods included in this package are aimed at preparing data for export.

## Installation

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("ulchc/vary")
```

## Usage

After installation from GitHub, you can load it with:
```{r, eval=TRUE}
library(vary)
```

```{r, include=FALSE}
library(tidyr)
library(dplyr)

data <- tibble(
  ID     = "5.1.0",
  Code   = "222",
  Name   = "Book",
  Day    = "Friday",
  Month  = "APR",
  Amount = "19.00"
)

messy_data <- tibble(
  `Amount $`           = "20.00",
  `Month (MMM) `       = "MAY",
  `Day of \n the week` = "Saturday",
  `Product\nName`      = "Notebook",
   Barcode             = "223",
  `ID #`               = "5.1.1"
)

color_phrases <- c(
  "The sunrise was yellow",
  "There were purple flowers",
  "The water was blue"
)

colors_list <- c(
  "Red",
  "Blue",
  "Green",
  "Yellow",
  "Violet",
  "Purple",
  "Orange"
)

set.seed(1)
mismatched <- tidyr::table2
n_rows <- sample(nrow(mismatched), 5)
mismatched[n_rows, 1] <- table2[n_rows, 3]
mismatched[n_rows, 3] <- table2[n_rows, 1]
```

Use fuzzy_rename() when it is known that the underlying data between two sources is equivalent 
```{r}
# The attributes of data and messy_data are the same, but naming conventions between the sources differ
```

```{r}
data
messy_data
```

```{r}
names(data) %in% names(messy_data)

# No names are compatible between sources
```

```{r}
names(data) %in% names(fuzzy_rename(messy_data, names(data)))

# fuzzy_rename() will match names and print out the changes
```

Automatically match, reorder, and combine without making manual adjustments
```{r}
messy_data %>%
  fuzzy_rename(data) %>%
  select(names(data)) %>%
  rbind(data)
```

Use fuzzy_match() to detect similarities between different sized character vectors
```{r}
colors_list
```
```{r}
color_phrases
```

```{r}
colors_mentioned <- fuzzy_match(color_phrases, colors_list)
```
```{r}
writeLines(paste0("The colors mentioned were: ", paste0(colors_mentioned, collapse = ", ")))
```

Use which_rows() to filter data with mismatched columns
```{r}
# Mismatched columns: country < -- > type
```
```{r}
mismatched
```

```{r}
row_index <-
  which_rows(
    mismatched,
    contain_strings = c("CASES", "2000"),
    all_strings = TRUE,
    case_sensitive = FALSE,
    flatten = TRUE
  )
```

```{r}
# Using which_rows() is a non-verbose option to filter data prior to resolving mismatched attributes
```
```{r}
mismatched[row_index, ]
```

```{r}
# filter would not work under these conditions and would only return 2/3 of the rows 
```
```{r}
mismatched %>% filter(type == "cases" & year == 2000)
```

## R Documentation

##### Use ?vary to view a linked list of all functions

```{r, eval=FALSE}
# Structure Data
?which_rows()
?fuzzy_match()
?fuzzy_rename()
?flatten_page_list()
?drop_na_rows()
?drop_na_cols()

# Locate Files
?get_downloads_folder()
?files_matching()

# Other (possible future relocation)
?clean_cols_in()
?clean_cols_out()
?`%notin%`
```
